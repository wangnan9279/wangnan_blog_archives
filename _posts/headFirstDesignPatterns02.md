---
layout: post
title: 《Head First 设计模式》书摘-装饰者模式/抽象工厂模式/工厂方法模式
date: 2017-06-13 16:00:52
tags: [设计模式]
categories: 设计模式
comments: true
toc: true
link_title: headFirstDesignPatterns02
---
![](http://onxkn9cbz.bkt.clouddn.com/dp02.jpg)
# 装饰者模式
## 定义
动态地将责任附加到对象上，想要扩展功能，装饰者提供有别于继承的另一种选择

<!--more-->

## get到的oo原则
- 对扩展开放，对修改关闭

## 要点
- 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
- 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
- 组合和委托可用于在运行时动态地加上新的行为。
- 除了继承，装饰者模式也可以让我们扩展行为。
- 装饰者模式意味着一群装饰者类， 这些类用来包装具体组件。
- 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。
- 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为， 甚至将被装饰者的行为整个取代掉，而达到特定的目的。
- 你可以用无数个装饰者包装一个组件。
- 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
- 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

# 抽象工厂模式/工厂方法模式
## 抽象工厂模式定义
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
## 工厂方法模式定义
定义一个创建对象的接口，但由子类绝对实例化的类是哪一个，工厂方法让类把实例化推迟到子类

## get到的oo原则
- 依赖抽象，不是依赖具体类

## 要点
- 所有的工厂都是用来对象的创建
- 简单工厂，虽然不是真正的设计模式，但仍不失一个简单的方法，可以将客户端程序从具体类解耦
- 工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象
- 抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中
- 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合
- 工厂方法允许类将实例化延迟到子类进行
- 抽象工厂创建相关的对象家族，而不需要依赖他们的具体类
- 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象
- 工厂是很有威力的技巧，帮助我们针对抽象变成，而不是针对具体类编程
