---
layout: post
title: 《HeadFirst设计模式》书摘-状态模式/代理模式
date: 2017-04-28 15:52:30
tags: [设计模式]
categories: 书摘
link_title: headFirstDesignPatterns05
thumbnailImage: http://onxkn9cbz.bkt.clouddn.com/dp01.jpg
thumbnailImagePosition: left
---
<!-- toc -->
<!-- more -->
![](http://onxkn9cbz.bkt.clouddn.com/dp01.jpg)
# 状态模式
## 定义
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
## get到的oo原则
类应该只有一个改变的理由
## 要点
- 状态模式允许一个对象基于内部状态而拥有不同的行为
- 和程序状态机(PSM)不同，状态模式用类代表状态
- context会将行为委托给当前状态对象
- 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了
- 状态模式和策略模式有相同的类图，但是他们意图不同
- 策略模式通常会用行为或算法来配置context类
- 状态模式允许随着状态的改变而改变行为
- 状态转换可以由state类或context类控制
- 使用状态模式通常会导致设计中类的数目大量增加
- 状态类可以被多个context实例共享

# 代理模式
## 定义
为另一个对象提供一个替身或占位符以访问这个对象
## 要点
- 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种
- 远程代理管理客户和远程对象之间的交互
- 虚拟代理控制访问实例化开销大的对象
- 保护代理基于调用者控制对象方法的访问
- 代理模式有许多变体，例如：缓存代理，同步代理，防火墙代理和写入时复制代理
- 代理在结构上类似装饰者，但是目的不同
- 装饰者模式为对象加上行为，而代理则是控制访问
- java内置的代理支持，可以根据需要建立动态代理，并将所要调用分配到所选的处理器
- 就和其他包装者一样，代理会造成你的设计中的类数目增加